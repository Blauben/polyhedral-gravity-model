#pragma once

#include <set>
#include <memory>
#include <algorithm>
#include "thrust/copy.h"
#include "thrust/transform_reduce.h"
#include "thrust/execution_policy.h"
#include "thrust/iterator/counting_iterator.h"
#include "Polyhedron.h"
#include "GravityModelData.h"
#include "polyhedralGravity/util/UtilityContainer.h"
#include "polyhedralGravity/util/UtilityConstants.h"
#include "polyhedralGravity/model/PolyhedronTransform.h"

namespace polyhedralGravity::MeshChecking {

    /**
     * Checks if the vertices are in such a order that the unit normals of each plane point outwards the polyhedron
     * @param polyhedron the polyhedron consisting of vertices and triangular faces
     * @param normalOrientation
     * @return true if all the unit normals are pointing outwards
     *
     * @note This has quadratic complexity @f$O(n^2)@f$! For bigger problem sizes, K-D trees/ Octrees could improve
     * the complexity to determine the intersections
     * (see https://stackoverflow.com/questions/45603469/how-to-calculate-the-normals-of-a-box)
     */
    bool checkPlaneUnitNormalOrientation(const Polyhedron &polyhedron, const NormalOrientation& normalOrientation = NormalOrientation::OUTWARDS);

    /**
     * This method determines the majority vertex ordering of a polyhedron and the set of faces which
     * violate the majority constraint and need to be adpated.
     * Hence, if the set is empty, all faces obey to the returned ordering/ plane unit normal orientation.
     *
     * @param polyhedron the polyhedron consisting of vertices and triangular faces
     * @return a pair consisting of majority ordering (OUTWARDS or INWARDS pointing normals)
     *  and a set of face indices which violate the constraint
     */
    std::pair<NormalOrientation, std::set<size_t>> getPlaneUnitNormalOrientation(const Polyhedron &polyhedron);

    /**
     * Checks if no triangle is degenerated by checking the surface area being greater than zero.
     * E.g. two points are the same or all three are collinear.
     * @param polyhedron the polyhedron consisting of vertices and triangular faces
     * @return true if triangles are fine and none of them is degenerate
     */
    bool checkTrianglesNotDegenerated(const Polyhedron &polyhedron);


    namespace detail {

        /**
         * Calculates how often a vector starting at a specific origin intersects a polyhedron's mesh's triangles.
         * @param face the vector describing the ray
         * @param polyhedron the polyhedron consisting of vertices and triangular faces
         * @return true if the ray intersects the triangle
         */
        size_t
        countRayPolyhedronIntersections(const Array3Triplet& face, const Polyhedron &polyhedron);

        /**
         * Calculates how often a vector starting at a specific origin intersects a triangular face.
         * Uses the Möller–Trumbore intersection algorithm.
         * @param rayOrigin the origin of the ray
         * @param rayVector the vector describing the ray
         * @param triangle a triangular face
         * @return intersection point or null
         *
         * @related Adapted from https://en.wikipedia.org/wiki/Möller–Trumbore_intersection_algorithm
         */
        std::unique_ptr<Array3>
        rayIntersectsTriangle(const Array3 &rayOrigin, const Array3 &rayVector, const Array3Triplet &triangle);

    }

}
